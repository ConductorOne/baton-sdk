package config

import (
	"os"
	"strings"
	"text/template"

	"github.com/conductorone/baton-sdk/pkg/field"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

// Converts kebab-case "foo-bar-baz" to PascalCase "FooBarBaz".
func toPascalCase(input string) string {
	words := strings.Split(input, "-") // Split into words
	caser := cases.Title(language.AmericanEnglish)
	for i, word := range words {
		words[i] = caser.String(word)
	}
	return strings.Join(words, "") // Join without spaces
}

func Generate(name string, schema field.Configuration) {
	if name == "" {
		panic("name cannot be empty")
	}
	if len(schema.Fields) == 0 {
		panic("schema must contain at least one field")
	}

	defaultGroupCount := 0
	for _, group := range schema.FieldGroups {
		if group.Default {
			defaultGroupCount++
		}
	}

	if defaultGroupCount > 1 {
		panic("schema must not contain more than one default field group")
	}

	confschema := schema
	confschema.Fields = append(confschema.Fields, field.DefaultFields...)
	// Ensure unique fields
	uniqueFields := make(map[string]field.SchemaField)
	for _, f := range confschema.Fields {
		uniqueFields[f.FieldName] = f
	}
	confschema.Fields = make([]field.SchemaField, 0, len(uniqueFields))
	for _, f := range uniqueFields {
		confschema.Fields = append(confschema.Fields, f)
	}

	type FieldInfo struct {
		FieldName string
		FieldType string
		Tag       string
	}
	type StructInfo struct {
		StructName string
		Fields     []FieldInfo
	}

	data := StructInfo{
		StructName: toPascalCase(name),
		Fields:     []FieldInfo{},
	}
	for _, f := range schema.Fields {
		if f.ExportTarget != field.ExportTargetGUI && f.ExportTarget != field.ExportTargetOps && f.ExportTarget != field.ExportTargetCLIOnly {
			continue
		}
		fieldName := f.StructFieldName
		if fieldName == "" {
			fieldName = toPascalCase(f.FieldName)
		}

		nf := FieldInfo{
			FieldName: fieldName,
			Tag:       f.FieldName,
		}
		switch f.Variant {
		case field.StringVariant:
			if f.ConnectorConfig.FieldType == field.FileUpload {
				nf.FieldType = "[]byte"
			} else {
				nf.FieldType = "string"
			}
		case field.BoolVariant:
			nf.FieldType = "bool"
		case field.IntVariant:
			nf.FieldType = "int"
		case field.StringSliceVariant:
			nf.FieldType = "[]string"
		case field.StringMapVariant:
			nf.FieldType = "map[string]any"
		}
		data.Fields = append(data.Fields, nf)
	}
	tmpl, err := template.New("struct").Parse(structTemplate)
	if err != nil {
		panic(err)
	}
	// Create output file
	f, err := os.Create("conf.gen.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	// Execute the template and write to file
	if err := tmpl.Execute(f, data); err != nil {
		panic(err)
	}
}

const structTemplate = `// Code generated by baton-sdk. DO NOT EDIT!!!
package config

import "reflect" 

type {{ .StructName }} struct {
	{{- range .Fields }}
	{{ .FieldName }} {{ .FieldType }} ` + "`mapstructure:\"{{ .Tag }}\"`" + `
	{{- end }}
}

func (c *{{ .StructName }}) findFieldByTag(tagValue string) (any, bool) {
	v := reflect.ValueOf(c).Elem() // Dereference pointer to struct
	t := v.Type()

	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag.Get("mapstructure")

		if tag == tagValue {
			return v.Field(i).Interface(), true
		}
	}
	return nil, false
}

func (c *{{ .StructName }}) GetStringSlice(fieldName string) []string {
	v, ok := c.findFieldByTag(fieldName)
	if !ok {
		return []string{}
	}
	t, ok := v.([]string)
	if !ok {
		panic("wrong type")
	}
	return t
}

func (c *{{ .StructName }}) GetString(fieldName string) string {
	v, ok := c.findFieldByTag(fieldName)
	if !ok {
		return ""
	}
	if t, ok := v.(string); ok {
		return t
	}
	if t, ok := v.([]byte); ok {
		return string(t)
	}
	panic("wrong type")
}

func (c *{{ .StructName }}) GetInt(fieldName string) int {
	v, ok := c.findFieldByTag(fieldName)
	if !ok {
		return 0
	}
	t, ok := v.(int)
	if !ok {
		panic("wrong type")
	}
	return t
}

func (c *{{ .StructName }}) GetBool(fieldName string) bool {
	v, ok := c.findFieldByTag(fieldName)
	if !ok {
		return false
	}
	t, ok := v.(bool)
	if !ok {
		panic("wrong type")
	}
	return t
}

func (c *{{ .StructName }}) GetStringMap(fieldName string) map[string]any {
	v, ok := c.findFieldByTag(fieldName)
	if !ok {
		return map[string]any{}
	}
	t, ok := v.(map[string]any)
	if !ok {
		panic("wrong type")
	}
	return t
}
`
