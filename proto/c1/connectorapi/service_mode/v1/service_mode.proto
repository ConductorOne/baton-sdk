syntax = "proto3";

package c1.connectorapi.service_mode.v1;

option go_package = "github.com/conductorone/baton-sdk/pb/c1/connectorapi/service_mode/v1";

import "c1/connector/v2/resource.proto";
import "c1/connector/v2/entitlement.proto";
import "c1/connector/v2/connector.proto";
import "c1/connector/v2/grant.proto";
import "google/protobuf/any.proto";
import "google/protobuf/duration.proto";

service ConnectorWorkService {
  rpc Hello(HelloRequest) returns (HelloResponse) {};
  rpc GetTask(GetTaskRequest) returns (GetTaskResponse) {};

  // Connector calls this to inform the platform that it is still working on the task
  // If after sometime we don't hear a heartbeat, the platform should scrap the work and move it back to pending
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {};

  // Once the task is finished, the connector streams the results of the task
  rpc FinishTask(FinishTaskRequest) returns (FinishTaskResponse) {};
  rpc UploadAsset(stream UploadAssetRequest) returns (UploadAssetResponse) {};
}

message Task {
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_PENDING = 1;
    STATUS_SCHEDULED = 2;
    STATUS_RUNNING = 3;
    STATUS_FINISHED = 4;
  }

  message NoneTask {
    repeated google.protobuf.Any annotations = 1;
  }

  message HelloTask {
    repeated google.protobuf.Any annotations = 1;
  }

  message SyncFullTask {
    repeated google.protobuf.Any annotations = 1;
  }

  message GrantTask {
    connector.v2.Entitlement entitlement = 1;
    connector.v2.Resource principal = 2;
    repeated google.protobuf.Any annotations = 3;
  }

  message RevokeTask {
    connector.v2.Grant grant = 1;
    repeated google.protobuf.Any annotations = 2;
  }

  string id = 1;
  Status status = 2;
  oneof task_type {
    NoneTask none = 100;
    HelloTask hello = 101;
    SyncFullTask sync_full = 102;
    GrantTask grant = 103;
    RevokeTask revoke = 104;
  }
}

message HelloRequest {
  string host_id = 1;
  string task_id = 2; // You may say Hello anytime, but if you are responding to a task, you must provide the task_id
  c1.connector.v2.ConnectorMetadata connector_metadata = 3;
  repeated google.protobuf.Any annotations = 4;
}

message HelloResponse {
  repeated google.protobuf.Any annotations = 1;
}

message GetTaskRequest {
  string host_id = 1;
}

message GetTaskResponse {
  Task task = 1;
  google.protobuf.Duration next_poll = 2;
  google.protobuf.Duration next_deadline = 3;
  repeated google.protobuf.Any annotations = 4;
}

message HeartbeatRequest {
  string host_id = 1;
  string task_id = 2;
  repeated google.protobuf.Any annotations = 3; // Useful for returning status updates on the task
}

message HeartbeatResponse {
  google.protobuf.Duration next_deadline = 1;
  bool cancelled = 2; // Backend has decided that we should stop working on this
  repeated google.protobuf.Any annotations = 3;
}

message UploadAssetRequest {
  message UploadMetadata {
    string host_id = 1;
    string task_id = 2;
    repeated google.protobuf.Any annotations = 3;
  }

  message UploadData {
    // 4MB limit
    bytes data = 1;
  }

  message UploadEOF {
    bytes sha256_checksum = 1;
    repeated google.protobuf.Any annotations = 2;
  }

  oneof msg {
    UploadMetadata metadata = 100;
    UploadData data = 101;
    UploadEOF eof = 102;
  }
}

message UploadAssetResponse {
  repeated google.protobuf.Any annotations = 1;
}

// Connector submits a task has been finished. It should always be removed from the queue, and if it isn't a fatal error, we should re-add it to the queue to try again.
message FinishTaskRequest {
  string host_id = 1;
  string task_id = 2;

  message Error {
    string error = 1;
    bool fatal = 2;
    repeated google.protobuf.Any annotations = 3;
  }

  message Success {
    repeated google.protobuf.Any annotations = 3;
  }

  oneof final_state {
    Error error = 100;
    Success success = 101;
  }
}

message FinishTaskResponse {
  repeated google.protobuf.Any annotations = 1;
}
