// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: c1/connectorapi/baton/v1/baton.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Task with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Task) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaskMultiError, or nil if none found.
func (m *Task) ValidateAll() error {
	return m.validate(true)
}

func (m *Task) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Status

	switch v := m.TaskType.(type) {
	case *Task_None:
		if v == nil {
			err := TaskValidationError{
				field:  "TaskType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNone()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "None",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "None",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNone()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskValidationError{
					field:  "None",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Task_Hello:
		if v == nil {
			err := TaskValidationError{
				field:  "TaskType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHello()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "Hello",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "Hello",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHello()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskValidationError{
					field:  "Hello",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Task_SyncFull:
		if v == nil {
			err := TaskValidationError{
				field:  "TaskType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSyncFull()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "SyncFull",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "SyncFull",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSyncFull()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskValidationError{
					field:  "SyncFull",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Task_Grant:
		if v == nil {
			err := TaskValidationError{
				field:  "TaskType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGrant()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "Grant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "Grant",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGrant()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskValidationError{
					field:  "Grant",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Task_Revoke:
		if v == nil {
			err := TaskValidationError{
				field:  "TaskType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRevoke()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "Revoke",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskValidationError{
						field:  "Revoke",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRevoke()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskValidationError{
					field:  "Revoke",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TaskMultiError(errors)
	}

	return nil
}

// TaskMultiError is an error wrapping multiple validation errors returned by
// Task.ValidateAll() if the designated constraints aren't met.
type TaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskMultiError) AllErrors() []error { return m }

// TaskValidationError is the validation error returned by Task.Validate if the
// designated constraints aren't met.
type TaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskValidationError) ErrorName() string { return "TaskValidationError" }

// Error satisfies the builtin error interface
func (e TaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskValidationError{}

// Validate checks the field values on BatonServiceHelloRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceHelloRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceHelloRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatonServiceHelloRequestMultiError, or nil if none found.
func (m *BatonServiceHelloRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceHelloRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetHostId()); l < 1 || l > 256 {
		err := BatonServiceHelloRequestValidationError{
			field:  "HostId",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BatonServiceHelloRequest_TaskId_Pattern.MatchString(m.GetTaskId()) {
		err := BatonServiceHelloRequestValidationError{
			field:  "TaskId",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9]{27}|$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetBuildInfo() == nil {
		err := BatonServiceHelloRequestValidationError{
			field:  "BuildInfo",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBuildInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceHelloRequestValidationError{
					field:  "BuildInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceHelloRequestValidationError{
					field:  "BuildInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuildInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceHelloRequestValidationError{
				field:  "BuildInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetOsInfo() == nil {
		err := BatonServiceHelloRequestValidationError{
			field:  "OsInfo",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetOsInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceHelloRequestValidationError{
					field:  "OsInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceHelloRequestValidationError{
					field:  "OsInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOsInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceHelloRequestValidationError{
				field:  "OsInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetConnectorMetadata() == nil {
		err := BatonServiceHelloRequestValidationError{
			field:  "ConnectorMetadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetConnectorMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceHelloRequestValidationError{
					field:  "ConnectorMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceHelloRequestValidationError{
					field:  "ConnectorMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnectorMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceHelloRequestValidationError{
				field:  "ConnectorMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetAnnotations()) > 16 {
		err := BatonServiceHelloRequestValidationError{
			field:  "Annotations",
			reason: "value must contain no more than 16 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceHelloRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceHelloRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceHelloRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceHelloRequestMultiError(errors)
	}

	return nil
}

// BatonServiceHelloRequestMultiError is an error wrapping multiple validation
// errors returned by BatonServiceHelloRequest.ValidateAll() if the designated
// constraints aren't met.
type BatonServiceHelloRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceHelloRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceHelloRequestMultiError) AllErrors() []error { return m }

// BatonServiceHelloRequestValidationError is the validation error returned by
// BatonServiceHelloRequest.Validate if the designated constraints aren't met.
type BatonServiceHelloRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceHelloRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceHelloRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceHelloRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceHelloRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceHelloRequestValidationError) ErrorName() string {
	return "BatonServiceHelloRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceHelloRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceHelloRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceHelloRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceHelloRequestValidationError{}

var _BatonServiceHelloRequest_TaskId_Pattern = regexp.MustCompile("^[a-zA-Z0-9]{27}|$")

// Validate checks the field values on BatonServiceHelloResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceHelloResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceHelloResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatonServiceHelloResponseMultiError, or nil if none found.
func (m *BatonServiceHelloResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceHelloResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceHelloResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceHelloResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceHelloResponseValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceHelloResponseMultiError(errors)
	}

	return nil
}

// BatonServiceHelloResponseMultiError is an error wrapping multiple validation
// errors returned by BatonServiceHelloResponse.ValidateAll() if the
// designated constraints aren't met.
type BatonServiceHelloResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceHelloResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceHelloResponseMultiError) AllErrors() []error { return m }

// BatonServiceHelloResponseValidationError is the validation error returned by
// BatonServiceHelloResponse.Validate if the designated constraints aren't met.
type BatonServiceHelloResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceHelloResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceHelloResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceHelloResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceHelloResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceHelloResponseValidationError) ErrorName() string {
	return "BatonServiceHelloResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceHelloResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceHelloResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceHelloResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceHelloResponseValidationError{}

// Validate checks the field values on BatonServiceGetTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceGetTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceGetTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatonServiceGetTaskRequestMultiError, or nil if none found.
func (m *BatonServiceGetTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceGetTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetHostId()); l < 1 || l > 256 {
		err := BatonServiceGetTaskRequestValidationError{
			field:  "HostId",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatonServiceGetTaskRequestMultiError(errors)
	}

	return nil
}

// BatonServiceGetTaskRequestMultiError is an error wrapping multiple
// validation errors returned by BatonServiceGetTaskRequest.ValidateAll() if
// the designated constraints aren't met.
type BatonServiceGetTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceGetTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceGetTaskRequestMultiError) AllErrors() []error { return m }

// BatonServiceGetTaskRequestValidationError is the validation error returned
// by BatonServiceGetTaskRequest.Validate if the designated constraints aren't met.
type BatonServiceGetTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceGetTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceGetTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceGetTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceGetTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceGetTaskRequestValidationError) ErrorName() string {
	return "BatonServiceGetTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceGetTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceGetTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceGetTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceGetTaskRequestValidationError{}

// Validate checks the field values on BatonServiceGetTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceGetTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceGetTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatonServiceGetTaskResponseMultiError, or nil if none found.
func (m *BatonServiceGetTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceGetTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceGetTaskResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceGetTaskResponseValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceGetTaskResponseValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNextPoll()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceGetTaskResponseValidationError{
					field:  "NextPoll",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceGetTaskResponseValidationError{
					field:  "NextPoll",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextPoll()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceGetTaskResponseValidationError{
				field:  "NextPoll",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNextHeartbeat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceGetTaskResponseValidationError{
					field:  "NextHeartbeat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceGetTaskResponseValidationError{
					field:  "NextHeartbeat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextHeartbeat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceGetTaskResponseValidationError{
				field:  "NextHeartbeat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceGetTaskResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceGetTaskResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceGetTaskResponseValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceGetTaskResponseMultiError(errors)
	}

	return nil
}

// BatonServiceGetTaskResponseMultiError is an error wrapping multiple
// validation errors returned by BatonServiceGetTaskResponse.ValidateAll() if
// the designated constraints aren't met.
type BatonServiceGetTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceGetTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceGetTaskResponseMultiError) AllErrors() []error { return m }

// BatonServiceGetTaskResponseValidationError is the validation error returned
// by BatonServiceGetTaskResponse.Validate if the designated constraints
// aren't met.
type BatonServiceGetTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceGetTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceGetTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceGetTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceGetTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceGetTaskResponseValidationError) ErrorName() string {
	return "BatonServiceGetTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceGetTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceGetTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceGetTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceGetTaskResponseValidationError{}

// Validate checks the field values on BatonServiceHeartbeatRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceHeartbeatRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceHeartbeatRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BatonServiceHeartbeatRequestMultiError, or nil if none found.
func (m *BatonServiceHeartbeatRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceHeartbeatRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetHostId()); l < 1 || l > 256 {
		err := BatonServiceHeartbeatRequestValidationError{
			field:  "HostId",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BatonServiceHeartbeatRequest_TaskId_Pattern.MatchString(m.GetTaskId()) {
		err := BatonServiceHeartbeatRequestValidationError{
			field:  "TaskId",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9]{27}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetAnnotations()) > 16 {
		err := BatonServiceHeartbeatRequestValidationError{
			field:  "Annotations",
			reason: "value must contain no more than 16 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceHeartbeatRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceHeartbeatRequestValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceHeartbeatRequestValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceHeartbeatRequestMultiError(errors)
	}

	return nil
}

// BatonServiceHeartbeatRequestMultiError is an error wrapping multiple
// validation errors returned by BatonServiceHeartbeatRequest.ValidateAll() if
// the designated constraints aren't met.
type BatonServiceHeartbeatRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceHeartbeatRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceHeartbeatRequestMultiError) AllErrors() []error { return m }

// BatonServiceHeartbeatRequestValidationError is the validation error returned
// by BatonServiceHeartbeatRequest.Validate if the designated constraints
// aren't met.
type BatonServiceHeartbeatRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceHeartbeatRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceHeartbeatRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceHeartbeatRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceHeartbeatRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceHeartbeatRequestValidationError) ErrorName() string {
	return "BatonServiceHeartbeatRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceHeartbeatRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceHeartbeatRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceHeartbeatRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceHeartbeatRequestValidationError{}

var _BatonServiceHeartbeatRequest_TaskId_Pattern = regexp.MustCompile("^[a-zA-Z0-9]{27}$")

// Validate checks the field values on BatonServiceHeartbeatResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceHeartbeatResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceHeartbeatResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatonServiceHeartbeatResponseMultiError, or nil if none found.
func (m *BatonServiceHeartbeatResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceHeartbeatResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNextHeartbeat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceHeartbeatResponseValidationError{
					field:  "NextHeartbeat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceHeartbeatResponseValidationError{
					field:  "NextHeartbeat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNextHeartbeat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceHeartbeatResponseValidationError{
				field:  "NextHeartbeat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Cancelled

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceHeartbeatResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceHeartbeatResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceHeartbeatResponseValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceHeartbeatResponseMultiError(errors)
	}

	return nil
}

// BatonServiceHeartbeatResponseMultiError is an error wrapping multiple
// validation errors returned by BatonServiceHeartbeatResponse.ValidateAll()
// if the designated constraints aren't met.
type BatonServiceHeartbeatResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceHeartbeatResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceHeartbeatResponseMultiError) AllErrors() []error { return m }

// BatonServiceHeartbeatResponseValidationError is the validation error
// returned by BatonServiceHeartbeatResponse.Validate if the designated
// constraints aren't met.
type BatonServiceHeartbeatResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceHeartbeatResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceHeartbeatResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceHeartbeatResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceHeartbeatResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceHeartbeatResponseValidationError) ErrorName() string {
	return "BatonServiceHeartbeatResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceHeartbeatResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceHeartbeatResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceHeartbeatResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceHeartbeatResponseValidationError{}

// Validate checks the field values on BatonServiceUploadAssetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceUploadAssetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceUploadAssetRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatonServiceUploadAssetRequestMultiError, or nil if none found.
func (m *BatonServiceUploadAssetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceUploadAssetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	oneofMsgPresent := false
	switch v := m.Msg.(type) {
	case *BatonServiceUploadAssetRequest_Metadata:
		if v == nil {
			err := BatonServiceUploadAssetRequestValidationError{
				field:  "Msg",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofMsgPresent = true

		if all {
			switch v := interface{}(m.GetMetadata()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequestValidationError{
						field:  "Metadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequestValidationError{
						field:  "Metadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceUploadAssetRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BatonServiceUploadAssetRequest_Data:
		if v == nil {
			err := BatonServiceUploadAssetRequestValidationError{
				field:  "Msg",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofMsgPresent = true

		if all {
			switch v := interface{}(m.GetData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequestValidationError{
						field:  "Data",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceUploadAssetRequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BatonServiceUploadAssetRequest_Eof:
		if v == nil {
			err := BatonServiceUploadAssetRequestValidationError{
				field:  "Msg",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofMsgPresent = true

		if all {
			switch v := interface{}(m.GetEof()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequestValidationError{
						field:  "Eof",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequestValidationError{
						field:  "Eof",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEof()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceUploadAssetRequestValidationError{
					field:  "Eof",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofMsgPresent {
		err := BatonServiceUploadAssetRequestValidationError{
			field:  "Msg",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatonServiceUploadAssetRequestMultiError(errors)
	}

	return nil
}

// BatonServiceUploadAssetRequestMultiError is an error wrapping multiple
// validation errors returned by BatonServiceUploadAssetRequest.ValidateAll()
// if the designated constraints aren't met.
type BatonServiceUploadAssetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceUploadAssetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceUploadAssetRequestMultiError) AllErrors() []error { return m }

// BatonServiceUploadAssetRequestValidationError is the validation error
// returned by BatonServiceUploadAssetRequest.Validate if the designated
// constraints aren't met.
type BatonServiceUploadAssetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceUploadAssetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceUploadAssetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceUploadAssetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceUploadAssetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceUploadAssetRequestValidationError) ErrorName() string {
	return "BatonServiceUploadAssetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceUploadAssetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceUploadAssetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceUploadAssetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceUploadAssetRequestValidationError{}

// Validate checks the field values on BatonServiceUploadAssetResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceUploadAssetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceUploadAssetResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatonServiceUploadAssetResponseMultiError, or nil if none found.
func (m *BatonServiceUploadAssetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceUploadAssetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceUploadAssetResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceUploadAssetResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceUploadAssetResponseValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceUploadAssetResponseMultiError(errors)
	}

	return nil
}

// BatonServiceUploadAssetResponseMultiError is an error wrapping multiple
// validation errors returned by BatonServiceUploadAssetResponse.ValidateAll()
// if the designated constraints aren't met.
type BatonServiceUploadAssetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceUploadAssetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceUploadAssetResponseMultiError) AllErrors() []error { return m }

// BatonServiceUploadAssetResponseValidationError is the validation error
// returned by BatonServiceUploadAssetResponse.Validate if the designated
// constraints aren't met.
type BatonServiceUploadAssetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceUploadAssetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceUploadAssetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceUploadAssetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceUploadAssetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceUploadAssetResponseValidationError) ErrorName() string {
	return "BatonServiceUploadAssetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceUploadAssetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceUploadAssetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceUploadAssetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceUploadAssetResponseValidationError{}

// Validate checks the field values on BatonServiceFinishTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceFinishTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceFinishTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatonServiceFinishTaskRequestMultiError, or nil if none found.
func (m *BatonServiceFinishTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceFinishTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetHostId()); l < 1 || l > 256 {
		err := BatonServiceFinishTaskRequestValidationError{
			field:  "HostId",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BatonServiceFinishTaskRequest_TaskId_Pattern.MatchString(m.GetTaskId()) {
		err := BatonServiceFinishTaskRequestValidationError{
			field:  "TaskId",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9]{27}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BatonServiceFinishTaskRequestValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BatonServiceFinishTaskRequestValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BatonServiceFinishTaskRequestValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	oneofFinalStatePresent := false
	switch v := m.FinalState.(type) {
	case *BatonServiceFinishTaskRequest_Error_:
		if v == nil {
			err := BatonServiceFinishTaskRequestValidationError{
				field:  "FinalState",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofFinalStatePresent = true

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequestValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequestValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceFinishTaskRequestValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BatonServiceFinishTaskRequest_Success_:
		if v == nil {
			err := BatonServiceFinishTaskRequestValidationError{
				field:  "FinalState",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofFinalStatePresent = true

		if all {
			switch v := interface{}(m.GetSuccess()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequestValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequestValidationError{
						field:  "Success",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSuccess()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceFinishTaskRequestValidationError{
					field:  "Success",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofFinalStatePresent {
		err := BatonServiceFinishTaskRequestValidationError{
			field:  "FinalState",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatonServiceFinishTaskRequestMultiError(errors)
	}

	return nil
}

// BatonServiceFinishTaskRequestMultiError is an error wrapping multiple
// validation errors returned by BatonServiceFinishTaskRequest.ValidateAll()
// if the designated constraints aren't met.
type BatonServiceFinishTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceFinishTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceFinishTaskRequestMultiError) AllErrors() []error { return m }

// BatonServiceFinishTaskRequestValidationError is the validation error
// returned by BatonServiceFinishTaskRequest.Validate if the designated
// constraints aren't met.
type BatonServiceFinishTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceFinishTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceFinishTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceFinishTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceFinishTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceFinishTaskRequestValidationError) ErrorName() string {
	return "BatonServiceFinishTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceFinishTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceFinishTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceFinishTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceFinishTaskRequestValidationError{}

var _BatonServiceFinishTaskRequest_TaskId_Pattern = regexp.MustCompile("^[a-zA-Z0-9]{27}$")

// Validate checks the field values on BatonServiceFinishTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceFinishTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceFinishTaskResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatonServiceFinishTaskResponseMultiError, or nil if none found.
func (m *BatonServiceFinishTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceFinishTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceFinishTaskResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceFinishTaskResponseValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceFinishTaskResponseValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceFinishTaskResponseMultiError(errors)
	}

	return nil
}

// BatonServiceFinishTaskResponseMultiError is an error wrapping multiple
// validation errors returned by BatonServiceFinishTaskResponse.ValidateAll()
// if the designated constraints aren't met.
type BatonServiceFinishTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceFinishTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceFinishTaskResponseMultiError) AllErrors() []error { return m }

// BatonServiceFinishTaskResponseValidationError is the validation error
// returned by BatonServiceFinishTaskResponse.Validate if the designated
// constraints aren't met.
type BatonServiceFinishTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceFinishTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceFinishTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceFinishTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceFinishTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceFinishTaskResponseValidationError) ErrorName() string {
	return "BatonServiceFinishTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceFinishTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceFinishTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceFinishTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceFinishTaskResponseValidationError{}

// Validate checks the field values on Task_NoneTask with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Task_NoneTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task_NoneTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Task_NoneTaskMultiError, or
// nil if none found.
func (m *Task_NoneTask) ValidateAll() error {
	return m.validate(true)
}

func (m *Task_NoneTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Task_NoneTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Task_NoneTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Task_NoneTaskValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Task_NoneTaskMultiError(errors)
	}

	return nil
}

// Task_NoneTaskMultiError is an error wrapping multiple validation errors
// returned by Task_NoneTask.ValidateAll() if the designated constraints
// aren't met.
type Task_NoneTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Task_NoneTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Task_NoneTaskMultiError) AllErrors() []error { return m }

// Task_NoneTaskValidationError is the validation error returned by
// Task_NoneTask.Validate if the designated constraints aren't met.
type Task_NoneTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Task_NoneTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Task_NoneTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Task_NoneTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Task_NoneTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Task_NoneTaskValidationError) ErrorName() string { return "Task_NoneTaskValidationError" }

// Error satisfies the builtin error interface
func (e Task_NoneTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask_NoneTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Task_NoneTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Task_NoneTaskValidationError{}

// Validate checks the field values on Task_HelloTask with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Task_HelloTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task_HelloTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Task_HelloTaskMultiError,
// or nil if none found.
func (m *Task_HelloTask) ValidateAll() error {
	return m.validate(true)
}

func (m *Task_HelloTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Task_HelloTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Task_HelloTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Task_HelloTaskValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Task_HelloTaskMultiError(errors)
	}

	return nil
}

// Task_HelloTaskMultiError is an error wrapping multiple validation errors
// returned by Task_HelloTask.ValidateAll() if the designated constraints
// aren't met.
type Task_HelloTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Task_HelloTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Task_HelloTaskMultiError) AllErrors() []error { return m }

// Task_HelloTaskValidationError is the validation error returned by
// Task_HelloTask.Validate if the designated constraints aren't met.
type Task_HelloTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Task_HelloTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Task_HelloTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Task_HelloTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Task_HelloTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Task_HelloTaskValidationError) ErrorName() string { return "Task_HelloTaskValidationError" }

// Error satisfies the builtin error interface
func (e Task_HelloTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask_HelloTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Task_HelloTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Task_HelloTaskValidationError{}

// Validate checks the field values on Task_SyncFullTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Task_SyncFullTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task_SyncFullTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Task_SyncFullTaskMultiError, or nil if none found.
func (m *Task_SyncFullTask) ValidateAll() error {
	return m.validate(true)
}

func (m *Task_SyncFullTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Task_SyncFullTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Task_SyncFullTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Task_SyncFullTaskValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Task_SyncFullTaskMultiError(errors)
	}

	return nil
}

// Task_SyncFullTaskMultiError is an error wrapping multiple validation errors
// returned by Task_SyncFullTask.ValidateAll() if the designated constraints
// aren't met.
type Task_SyncFullTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Task_SyncFullTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Task_SyncFullTaskMultiError) AllErrors() []error { return m }

// Task_SyncFullTaskValidationError is the validation error returned by
// Task_SyncFullTask.Validate if the designated constraints aren't met.
type Task_SyncFullTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Task_SyncFullTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Task_SyncFullTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Task_SyncFullTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Task_SyncFullTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Task_SyncFullTaskValidationError) ErrorName() string {
	return "Task_SyncFullTaskValidationError"
}

// Error satisfies the builtin error interface
func (e Task_SyncFullTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask_SyncFullTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Task_SyncFullTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Task_SyncFullTaskValidationError{}

// Validate checks the field values on Task_GrantTask with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Task_GrantTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task_GrantTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Task_GrantTaskMultiError,
// or nil if none found.
func (m *Task_GrantTask) ValidateAll() error {
	return m.validate(true)
}

func (m *Task_GrantTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEntitlement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Task_GrantTaskValidationError{
					field:  "Entitlement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Task_GrantTaskValidationError{
					field:  "Entitlement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEntitlement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Task_GrantTaskValidationError{
				field:  "Entitlement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrincipal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Task_GrantTaskValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Task_GrantTaskValidationError{
					field:  "Principal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrincipal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Task_GrantTaskValidationError{
				field:  "Principal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Task_GrantTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Task_GrantTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Task_GrantTaskValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Task_GrantTaskMultiError(errors)
	}

	return nil
}

// Task_GrantTaskMultiError is an error wrapping multiple validation errors
// returned by Task_GrantTask.ValidateAll() if the designated constraints
// aren't met.
type Task_GrantTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Task_GrantTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Task_GrantTaskMultiError) AllErrors() []error { return m }

// Task_GrantTaskValidationError is the validation error returned by
// Task_GrantTask.Validate if the designated constraints aren't met.
type Task_GrantTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Task_GrantTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Task_GrantTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Task_GrantTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Task_GrantTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Task_GrantTaskValidationError) ErrorName() string { return "Task_GrantTaskValidationError" }

// Error satisfies the builtin error interface
func (e Task_GrantTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask_GrantTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Task_GrantTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Task_GrantTaskValidationError{}

// Validate checks the field values on Task_RevokeTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Task_RevokeTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task_RevokeTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Task_RevokeTaskMultiError, or nil if none found.
func (m *Task_RevokeTask) ValidateAll() error {
	return m.validate(true)
}

func (m *Task_RevokeTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGrant()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Task_RevokeTaskValidationError{
					field:  "Grant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Task_RevokeTaskValidationError{
					field:  "Grant",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrant()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Task_RevokeTaskValidationError{
				field:  "Grant",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Task_RevokeTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Task_RevokeTaskValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Task_RevokeTaskValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Task_RevokeTaskMultiError(errors)
	}

	return nil
}

// Task_RevokeTaskMultiError is an error wrapping multiple validation errors
// returned by Task_RevokeTask.ValidateAll() if the designated constraints
// aren't met.
type Task_RevokeTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Task_RevokeTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Task_RevokeTaskMultiError) AllErrors() []error { return m }

// Task_RevokeTaskValidationError is the validation error returned by
// Task_RevokeTask.Validate if the designated constraints aren't met.
type Task_RevokeTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Task_RevokeTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Task_RevokeTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Task_RevokeTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Task_RevokeTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Task_RevokeTaskValidationError) ErrorName() string { return "Task_RevokeTaskValidationError" }

// Error satisfies the builtin error interface
func (e Task_RevokeTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask_RevokeTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Task_RevokeTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Task_RevokeTaskValidationError{}

// Validate checks the field values on BatonServiceHelloRequest_BuildInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BatonServiceHelloRequest_BuildInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceHelloRequest_BuildInfo
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BatonServiceHelloRequest_BuildInfoMultiError, or nil if none found.
func (m *BatonServiceHelloRequest_BuildInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceHelloRequest_BuildInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetLangVersion()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_BuildInfoValidationError{
			field:  "LangVersion",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPackage()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_BuildInfoValidationError{
			field:  "Package",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPackageVersion()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_BuildInfoValidationError{
			field:  "PackageVersion",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatonServiceHelloRequest_BuildInfoMultiError(errors)
	}

	return nil
}

// BatonServiceHelloRequest_BuildInfoMultiError is an error wrapping multiple
// validation errors returned by
// BatonServiceHelloRequest_BuildInfo.ValidateAll() if the designated
// constraints aren't met.
type BatonServiceHelloRequest_BuildInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceHelloRequest_BuildInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceHelloRequest_BuildInfoMultiError) AllErrors() []error { return m }

// BatonServiceHelloRequest_BuildInfoValidationError is the validation error
// returned by BatonServiceHelloRequest_BuildInfo.Validate if the designated
// constraints aren't met.
type BatonServiceHelloRequest_BuildInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceHelloRequest_BuildInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceHelloRequest_BuildInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceHelloRequest_BuildInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceHelloRequest_BuildInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceHelloRequest_BuildInfoValidationError) ErrorName() string {
	return "BatonServiceHelloRequest_BuildInfoValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceHelloRequest_BuildInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceHelloRequest_BuildInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceHelloRequest_BuildInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceHelloRequest_BuildInfoValidationError{}

// Validate checks the field values on BatonServiceHelloRequest_OSInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BatonServiceHelloRequest_OSInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceHelloRequest_OSInfo with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// BatonServiceHelloRequest_OSInfoMultiError, or nil if none found.
func (m *BatonServiceHelloRequest_OSInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceHelloRequest_OSInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetHostname()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "Hostname",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOs()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "Os",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPlatform()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "Platform",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPlatformVersion()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "PlatformVersion",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetPlatformFamily()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "PlatformFamily",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKernelVersion()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "KernelVersion",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetKernelArch()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "KernelArch",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetVirtualizationSystem()); l < 1 || l > 256 {
		err := BatonServiceHelloRequest_OSInfoValidationError{
			field:  "VirtualizationSystem",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatonServiceHelloRequest_OSInfoMultiError(errors)
	}

	return nil
}

// BatonServiceHelloRequest_OSInfoMultiError is an error wrapping multiple
// validation errors returned by BatonServiceHelloRequest_OSInfo.ValidateAll()
// if the designated constraints aren't met.
type BatonServiceHelloRequest_OSInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceHelloRequest_OSInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceHelloRequest_OSInfoMultiError) AllErrors() []error { return m }

// BatonServiceHelloRequest_OSInfoValidationError is the validation error
// returned by BatonServiceHelloRequest_OSInfo.Validate if the designated
// constraints aren't met.
type BatonServiceHelloRequest_OSInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceHelloRequest_OSInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceHelloRequest_OSInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceHelloRequest_OSInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceHelloRequest_OSInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceHelloRequest_OSInfoValidationError) ErrorName() string {
	return "BatonServiceHelloRequest_OSInfoValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceHelloRequest_OSInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceHelloRequest_OSInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceHelloRequest_OSInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceHelloRequest_OSInfoValidationError{}

// Validate checks the field values on
// BatonServiceUploadAssetRequest_UploadMetadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BatonServiceUploadAssetRequest_UploadMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// BatonServiceUploadAssetRequest_UploadMetadata with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// BatonServiceUploadAssetRequest_UploadMetadataMultiError, or nil if none found.
func (m *BatonServiceUploadAssetRequest_UploadMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceUploadAssetRequest_UploadMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetHostId()); l < 1 || l > 256 {
		err := BatonServiceUploadAssetRequest_UploadMetadataValidationError{
			field:  "HostId",
			reason: "value length must be between 1 and 256 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_BatonServiceUploadAssetRequest_UploadMetadata_TaskId_Pattern.MatchString(m.GetTaskId()) {
		err := BatonServiceUploadAssetRequest_UploadMetadataValidationError{
			field:  "TaskId",
			reason: "value does not match regex pattern \"^[a-zA-Z0-9]{27}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetAnnotations()) > 16 {
		err := BatonServiceUploadAssetRequest_UploadMetadataValidationError{
			field:  "Annotations",
			reason: "value must contain no more than 16 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequest_UploadMetadataValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequest_UploadMetadataValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceUploadAssetRequest_UploadMetadataValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceUploadAssetRequest_UploadMetadataMultiError(errors)
	}

	return nil
}

// BatonServiceUploadAssetRequest_UploadMetadataMultiError is an error wrapping
// multiple validation errors returned by
// BatonServiceUploadAssetRequest_UploadMetadata.ValidateAll() if the
// designated constraints aren't met.
type BatonServiceUploadAssetRequest_UploadMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceUploadAssetRequest_UploadMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceUploadAssetRequest_UploadMetadataMultiError) AllErrors() []error { return m }

// BatonServiceUploadAssetRequest_UploadMetadataValidationError is the
// validation error returned by
// BatonServiceUploadAssetRequest_UploadMetadata.Validate if the designated
// constraints aren't met.
type BatonServiceUploadAssetRequest_UploadMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceUploadAssetRequest_UploadMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceUploadAssetRequest_UploadMetadataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e BatonServiceUploadAssetRequest_UploadMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceUploadAssetRequest_UploadMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceUploadAssetRequest_UploadMetadataValidationError) ErrorName() string {
	return "BatonServiceUploadAssetRequest_UploadMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceUploadAssetRequest_UploadMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceUploadAssetRequest_UploadMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceUploadAssetRequest_UploadMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceUploadAssetRequest_UploadMetadataValidationError{}

var _BatonServiceUploadAssetRequest_UploadMetadata_TaskId_Pattern = regexp.MustCompile("^[a-zA-Z0-9]{27}$")

// Validate checks the field values on
// BatonServiceUploadAssetRequest_UploadData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BatonServiceUploadAssetRequest_UploadData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// BatonServiceUploadAssetRequest_UploadData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// BatonServiceUploadAssetRequest_UploadDataMultiError, or nil if none found.
func (m *BatonServiceUploadAssetRequest_UploadData) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceUploadAssetRequest_UploadData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetData()); l < 1 || l > 1048576 {
		err := BatonServiceUploadAssetRequest_UploadDataValidationError{
			field:  "Data",
			reason: "value length must be between 1 and 1048576 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BatonServiceUploadAssetRequest_UploadDataMultiError(errors)
	}

	return nil
}

// BatonServiceUploadAssetRequest_UploadDataMultiError is an error wrapping
// multiple validation errors returned by
// BatonServiceUploadAssetRequest_UploadData.ValidateAll() if the designated
// constraints aren't met.
type BatonServiceUploadAssetRequest_UploadDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceUploadAssetRequest_UploadDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceUploadAssetRequest_UploadDataMultiError) AllErrors() []error { return m }

// BatonServiceUploadAssetRequest_UploadDataValidationError is the validation
// error returned by BatonServiceUploadAssetRequest_UploadData.Validate if the
// designated constraints aren't met.
type BatonServiceUploadAssetRequest_UploadDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceUploadAssetRequest_UploadDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceUploadAssetRequest_UploadDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceUploadAssetRequest_UploadDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceUploadAssetRequest_UploadDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceUploadAssetRequest_UploadDataValidationError) ErrorName() string {
	return "BatonServiceUploadAssetRequest_UploadDataValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceUploadAssetRequest_UploadDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceUploadAssetRequest_UploadData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceUploadAssetRequest_UploadDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceUploadAssetRequest_UploadDataValidationError{}

// Validate checks the field values on BatonServiceUploadAssetRequest_UploadEOF
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *BatonServiceUploadAssetRequest_UploadEOF) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// BatonServiceUploadAssetRequest_UploadEOF with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// BatonServiceUploadAssetRequest_UploadEOFMultiError, or nil if none found.
func (m *BatonServiceUploadAssetRequest_UploadEOF) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceUploadAssetRequest_UploadEOF) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSha256Checksum()) != 32 {
		err := BatonServiceUploadAssetRequest_UploadEOFValidationError{
			field:  "Sha256Checksum",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetAnnotations()) > 16 {
		err := BatonServiceUploadAssetRequest_UploadEOFValidationError{
			field:  "Annotations",
			reason: "value must contain no more than 16 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequest_UploadEOFValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceUploadAssetRequest_UploadEOFValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceUploadAssetRequest_UploadEOFValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceUploadAssetRequest_UploadEOFMultiError(errors)
	}

	return nil
}

// BatonServiceUploadAssetRequest_UploadEOFMultiError is an error wrapping
// multiple validation errors returned by
// BatonServiceUploadAssetRequest_UploadEOF.ValidateAll() if the designated
// constraints aren't met.
type BatonServiceUploadAssetRequest_UploadEOFMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceUploadAssetRequest_UploadEOFMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceUploadAssetRequest_UploadEOFMultiError) AllErrors() []error { return m }

// BatonServiceUploadAssetRequest_UploadEOFValidationError is the validation
// error returned by BatonServiceUploadAssetRequest_UploadEOF.Validate if the
// designated constraints aren't met.
type BatonServiceUploadAssetRequest_UploadEOFValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceUploadAssetRequest_UploadEOFValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceUploadAssetRequest_UploadEOFValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceUploadAssetRequest_UploadEOFValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceUploadAssetRequest_UploadEOFValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceUploadAssetRequest_UploadEOFValidationError) ErrorName() string {
	return "BatonServiceUploadAssetRequest_UploadEOFValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceUploadAssetRequest_UploadEOFValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceUploadAssetRequest_UploadEOF.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceUploadAssetRequest_UploadEOFValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceUploadAssetRequest_UploadEOFValidationError{}

// Validate checks the field values on BatonServiceFinishTaskRequest_Error with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *BatonServiceFinishTaskRequest_Error) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceFinishTaskRequest_Error
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BatonServiceFinishTaskRequest_ErrorMultiError, or nil if none found.
func (m *BatonServiceFinishTaskRequest_Error) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceFinishTaskRequest_Error) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NonRetryable

	if len(m.GetAnnotations()) > 16 {
		err := BatonServiceFinishTaskRequest_ErrorValidationError{
			field:  "Annotations",
			reason: "value must contain no more than 16 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequest_ErrorValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequest_ErrorValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceFinishTaskRequest_ErrorValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceFinishTaskRequest_ErrorMultiError(errors)
	}

	return nil
}

// BatonServiceFinishTaskRequest_ErrorMultiError is an error wrapping multiple
// validation errors returned by
// BatonServiceFinishTaskRequest_Error.ValidateAll() if the designated
// constraints aren't met.
type BatonServiceFinishTaskRequest_ErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceFinishTaskRequest_ErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceFinishTaskRequest_ErrorMultiError) AllErrors() []error { return m }

// BatonServiceFinishTaskRequest_ErrorValidationError is the validation error
// returned by BatonServiceFinishTaskRequest_Error.Validate if the designated
// constraints aren't met.
type BatonServiceFinishTaskRequest_ErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceFinishTaskRequest_ErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceFinishTaskRequest_ErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceFinishTaskRequest_ErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceFinishTaskRequest_ErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceFinishTaskRequest_ErrorValidationError) ErrorName() string {
	return "BatonServiceFinishTaskRequest_ErrorValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceFinishTaskRequest_ErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceFinishTaskRequest_Error.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceFinishTaskRequest_ErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceFinishTaskRequest_ErrorValidationError{}

// Validate checks the field values on BatonServiceFinishTaskRequest_Success
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *BatonServiceFinishTaskRequest_Success) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatonServiceFinishTaskRequest_Success
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// BatonServiceFinishTaskRequest_SuccessMultiError, or nil if none found.
func (m *BatonServiceFinishTaskRequest_Success) ValidateAll() error {
	return m.validate(true)
}

func (m *BatonServiceFinishTaskRequest_Success) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetAnnotations()) > 16 {
		err := BatonServiceFinishTaskRequest_SuccessValidationError{
			field:  "Annotations",
			reason: "value must contain no more than 16 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequest_SuccessValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BatonServiceFinishTaskRequest_SuccessValidationError{
						field:  fmt.Sprintf("Annotations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BatonServiceFinishTaskRequest_SuccessValidationError{
					field:  fmt.Sprintf("Annotations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BatonServiceFinishTaskRequest_SuccessMultiError(errors)
	}

	return nil
}

// BatonServiceFinishTaskRequest_SuccessMultiError is an error wrapping
// multiple validation errors returned by
// BatonServiceFinishTaskRequest_Success.ValidateAll() if the designated
// constraints aren't met.
type BatonServiceFinishTaskRequest_SuccessMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatonServiceFinishTaskRequest_SuccessMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatonServiceFinishTaskRequest_SuccessMultiError) AllErrors() []error { return m }

// BatonServiceFinishTaskRequest_SuccessValidationError is the validation error
// returned by BatonServiceFinishTaskRequest_Success.Validate if the
// designated constraints aren't met.
type BatonServiceFinishTaskRequest_SuccessValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatonServiceFinishTaskRequest_SuccessValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatonServiceFinishTaskRequest_SuccessValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatonServiceFinishTaskRequest_SuccessValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatonServiceFinishTaskRequest_SuccessValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatonServiceFinishTaskRequest_SuccessValidationError) ErrorName() string {
	return "BatonServiceFinishTaskRequest_SuccessValidationError"
}

// Error satisfies the builtin error interface
func (e BatonServiceFinishTaskRequest_SuccessValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatonServiceFinishTaskRequest_Success.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatonServiceFinishTaskRequest_SuccessValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatonServiceFinishTaskRequest_SuccessValidationError{}
